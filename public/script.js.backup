/**
 * RealEngine - ChatGPT Style Interface
 * JavaScript Module for Image Generation
 */

class RealEngine {
  constructor() {
    this.currentChat = null;
    this.chatHistory = [];
    this.currentMode = "image"; // "image" or "chat"
    this.settings = {
      width: 1024,
      height: 1024,
      model: "runware:97@1", // Dream as default
      lora: "",
      lora2: "",
      steps: 28, // Dream default steps
      CFGScale: 3.5, // Dream default CFG
      negativePrompt: "worst quality, low quality, blurry", // Match iOS default
      scheduler: "FlowMatchEulerDiscreteScheduler", // Match iOS default
      seed: "",
      enhancePrompt: false,
      outputFormat: "JPG", // Match iOS default
      numberResults: 1,
    };
    this.isGenerating = false;
    this.modelDefaults = {
      "runware:97@1": { steps: 28, CFGScale: 3.5, name: "Dream" },
      "rundiffusion:130@100": { steps: 33, CFGScale: 3.0, name: "J-Pro" },
      "runware:101@1": { steps: 28, CFGScale: 3.5, name: "RealEngine v1" },
      "runware:120@4": { steps: 28, CFGScale: 3.5, name: "Layerz" },
    };
    this.recentPrompts = [];
    this.personalLoras = [];
    this.storageKey = "realengine_data";
    this.isInitialized = false;

    // Built-in LoRA definitions with trigger words
    this.builtInLoras = {
      "civitai:652699@993999": { name: "Realism", triggerWords: "" },
      "civitai:682349@763724": { name: "360degree", triggerWords: "" },
      "civitai:757432@846937": { name: "LogoMaker", triggerWords: "" },
      "civitai:669582@749547": { name: "TextLogo", triggerWords: "" },
      "rundiffusion:500@100": { name: "Photo", triggerWords: "" },
      "civitai:1260139@1420893": {
        name: "Medieval",
        triggerWords: "Illuminated manuscript illustration of",
      },
    };

    // Content filtering - disallowed words for image generation
    this.disallowedWords = [
      // Direct terms
      "kid",
      "kids",
      "child",
      "children",
      "minor",
      "minors",
      "teen",
      "teens",
      "teenager",
      "teenagers",
      "teenage",
      "underage",
      "baby",
      "babies",
      "infant",
      "infants",
      "young",
      "youth",
      "boy",
      "girl",
      "toddler",
      "toddlers",
      "school age",
      "schoolage",
      "juvenile",
      "juveniles",
      "little girl",
      "little boy",
      "young girl",
      "young boy",

      // Common misspellings and variations
      "kidz",
      "kiddo",
      "kiddos",
      "yung",
      "yunq",
      "bby",
      "bb",
      "lil girl",
      "lil boy",
      "smol",
      "loli",
      "shota",

      // Slang and abbreviations
      "jailbait",
      "barely legal",
      "fresh 18",
      "just turned 18",
      "high school",
      "highschool",
      "schoolgirl",
      "schoolboy",
      "preteen",
      "pre-teen",
      "tween",

      // Age-related numbers (13-17)
      "13 year",
      "14 year",
      "15 year",
      "16 year",
      "17 year",
      "13-year",
      "14-year",
      "15-year",
      "16-year",
      "17-year",
      "13yr",
      "14yr",
      "15yr",
      "16yr",
      "17yr",
      "thirteen",
      "fourteen",
      "fifteen",
      "sixteen",
      "seventeen",

      // Compound words and phrases
      "babydoll",
      "kidlike",
      "childlike",
      "youthful",
      "innocent girl",
      "innocent boy",
      "sweet girl",
      "sweet boy",
      "small girl",
      "small boy",
      "tiny girl",
      "tiny boy",

      // Character substitutions (common ones)
      "k1d",
      "k1ds",
      "ch1ld",
      "y0ung",
      "g1rl",
      "b0y",
      "t33n",
      "b4by",
      "m1nor",

      // International terms
      "niña",
      "niño",
      "bambina",
      "bambino",
      "enfant",
      "mädchen",
      "junge",
      "criança",
    ];

    this.init();
  }

  init() {
    this.loadFromStorage();
    this.bindEvents();
    this.initSettingsPanel();
    this.loadRandomPrompts();
    this.updateModelIndicator();
    this.showWelcomeMessage();
    this.isInitialized = true;
  }

  bindEvents() {
    // Form submission
    document.getElementById("imageForm").addEventListener("submit", (e) => {
      e.preventDefault();
      if (this.currentMode === "image") {
        this.generateImage();
      } else {
        this.sendChatMessage();
      }
    });

    // Mode toggle buttons
    document.getElementById("imageModeBtn").addEventListener("click", () => {
      this.switchMode("image");
    });

    document.getElementById("chatModeBtn").addEventListener("click", () => {
      this.switchMode("chat");
    });

    // Sidebar toggle (mobile)
    document.getElementById("sidebarToggle").addEventListener("click", () => {
      this.toggleSidebar();
    });

    // Settings panel
    document.getElementById("settingsBtn").addEventListener("click", () => {
      this.openSettings();
    });

    document.getElementById("closeSettings").addEventListener("click", () => {
      this.closeSettings();
    });

    document.getElementById("settingsOverlay").addEventListener("click", () => {
      this.closeSettings();
    });

    // Random prompt button
    document.getElementById("randomPromptBtn").addEventListener("click", () => {
      this.getRandomPrompt();
    });

    // New chat button
    document.getElementById("newChatBtn").addEventListener("click", () => {
      this.newChat();
    });

    // Prompt enhancer toggle
    document
      .getElementById("enhancerToggleBtn")
      .addEventListener("click", () => {
        this.toggleEnhancer();
      });

    // Clear history button
    document.getElementById("clearHistoryBtn").addEventListener("click", () => {
      this.clearHistory();
    });

    // Personal LoRA add button
    document
      .getElementById("addPersonalLoraBtn")
      .addEventListener("click", () => {
        this.addPersonalLora();
      });

    // Auto-resize textarea
    const textarea = document.getElementById("positivePrompt");
    textarea.addEventListener("input", () => {
      this.autoResizeTextarea(textarea);
    });

    // Enter key submission for textarea
    textarea.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        if (this.currentMode === "image") {
          this.generateImage();
        } else {
          this.sendChatMessage();
        }
      }
    });

    // Settings form elements
    this.bindSettingsEvents();

    // Keyboard shortcuts
    document.addEventListener("keydown", (e) => {
      // Ctrl/Cmd + Enter to generate
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
        e.preventDefault();
        this.generateImage();
      }
      // Escape to close settings
      if (e.key === "Escape") {
        this.closeSettings();
        // Also close sidebar on escape
        const sidebar = document.getElementById("sidebar");
        if (sidebar.classList.contains("open")) {
          sidebar.classList.remove("open");
        }
      }
    });

    // Click outside to close sidebar
    document.addEventListener("click", (e) => {
      const sidebar = document.getElementById("sidebar");
      const sidebarToggle = document.getElementById("sidebarToggle");

      // If sidebar is open and click is outside sidebar and not on toggle button
      if (
        sidebar.classList.contains("open") &&
        !sidebar.contains(e.target) &&
        !sidebarToggle.contains(e.target)
      ) {
        sidebar.classList.remove("open");
      }
    });
  }

  bindSettingsEvents() {
    // Aspect ratio buttons
    document.querySelectorAll(".aspect-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        this.setAspectRatio(btn);
      });
    });

    // Model selection
    document.getElementById("modelSelect").addEventListener("change", (e) => {
      this.settings.model = e.target.value;
      this.updateHiddenInput("model", e.target.value);
      this.applyModelDefaults();
      this.updateModelIndicator();
      this.handleLoRACompatibility(e.target.value);
      this.saveToStorage();
    });

    // LoRA selection
    document.getElementById("loraSelect").addEventListener("change", (e) => {
      // Don't allow LoRA selection for Dream model
      const isDreamModel = this.settings.model === "runware:97@1";

      if (isDreamModel) {
        // Reset to "None" if Dream model is selected
        e.target.value = "";
        this.settings.lora = "";
        this.updateHiddenInput("lora", "");
        this.showStatus("LoRA not compatible with Dream model", 3000);
      } else {
        this.settings.lora = e.target.value;
        this.updateHiddenInput("lora", e.target.value);
      }

      this.saveToStorage();
    });

    // LoRA weight slider
    const loraWeight = document.getElementById("loraWeight");
    loraWeight.addEventListener("input", (e) => {
      document.getElementById("loraWeightValue").textContent = parseFloat(
        e.target.value
      ).toFixed(2);
    });

    // CFG Scale slider
    const cfgScale = document.getElementById("cfgScaleSlider");
    cfgScale.addEventListener("input", (e) => {
      this.settings.CFGScale = parseFloat(e.target.value);
      document.getElementById("cfgScaleValue").textContent = parseFloat(
        e.target.value
      ).toFixed(2);
      this.updateHiddenInput("CFGScale", e.target.value);
    });

    // Steps slider
    const steps = document.getElementById("stepsSlider");
    steps.addEventListener("input", (e) => {
      this.settings.steps = parseInt(e.target.value);
      document.getElementById("stepsValue").textContent = parseInt(
        e.target.value
      ).toFixed(2);
      this.updateHiddenInput("steps", e.target.value);
    });

    // Negative prompt
    document
      .getElementById("negativePromptInput")
      .addEventListener("input", (e) => {
        this.settings.negativePrompt = e.target.value;
        this.updateHiddenInput("negativePrompt", e.target.value);
      });

    // Enhance prompt toggle
    document
      .getElementById("enhancePromptToggle")
      .addEventListener("change", (e) => {
        this.settings.enhancePrompt = e.target.checked;
        this.updateHiddenInput("enhanceToggle", e.target.checked);

        // Sync with main enhancer toggle
        const enhancerBtn = document.getElementById("enhancerToggleBtn");
        if (e.target.checked) {
          enhancerBtn.classList.add("active");
        } else {
          enhancerBtn.classList.remove("active");
        }
      });

    // Scheduler selection
    document
      .getElementById("schedulerSelect")
      .addEventListener("change", (e) => {
        this.settings.scheduler = e.target.value;
        this.updateHiddenInput("scheduler", e.target.value);
      });

    // Seed input
    document.getElementById("seedInput").addEventListener("input", (e) => {
      this.settings.seed = e.target.value;
      this.updateHiddenInput("seed", e.target.value);
    });
  }

  setAspectRatio(selectedBtn) {
    // Remove active class from all buttons
    document.querySelectorAll(".aspect-btn").forEach((btn) => {
      btn.classList.remove("active");
    });

    // Add active class to selected button
    selectedBtn.classList.add("active");

    // Update settings
    this.settings.width = parseInt(selectedBtn.dataset.width);
    this.settings.height = parseInt(selectedBtn.dataset.height);

    // Update hidden inputs
    this.updateHiddenInput("width", this.settings.width);
    this.updateHiddenInput("height", this.settings.height);

    // Save to storage
    this.saveToStorage();
  }

  updateHiddenInput(id, value) {
    const input = document.getElementById(id);
    if (input) {
      input.value = value;
    }
  }

  updateModelIndicator() {
    const modelSelect = document.getElementById("modelSelect");
    const indicator = document.getElementById("modelIndicator");
    const selectedOption = modelSelect.selectedOptions[0];
    if (selectedOption && indicator) {
      indicator.textContent = selectedOption.textContent;
    }
  }

  autoResizeTextarea(textarea) {
    textarea.style.height = "auto";
    textarea.style.height = Math.min(textarea.scrollHeight, 200) + "px";
  }

  toggleSidebar() {
    const sidebar = document.getElementById("sidebar");
    sidebar.classList.toggle("open");
  }

  openSettings() {
    const panel = document.getElementById("settingsPanel");
    const overlay = document.getElementById("settingsOverlay");
    panel.classList.add("open");
    overlay.classList.add("visible");
    document.body.style.overflow = "hidden";
  }

  closeSettings() {
    const panel = document.getElementById("settingsPanel");
    const overlay = document.getElementById("settingsOverlay");
    panel.classList.remove("open");
    overlay.classList.remove("visible");
    document.body.style.overflow = "";
  }

  showWelcomeMessage() {
    const chatContainer = document.getElementById("chatContainer");
    if (!chatContainer.querySelector(".welcome-message")) {
      chatContainer.innerHTML = `
                <div class="welcome-message">
                    <h2>Welcome to RealEngine</h2>
                    <p>Enter a prompt to generate AI images</p>
                    <button class="random-prompt-btn" onclick="realEngine.getRandomPrompt()">Get Random Prompt</button>
                </div>
            `;
    }
  }

  newChat() {
    this.currentChat = null;
    this.showWelcomeMessage();
    document.getElementById("positivePrompt").value = "";
    this.showStatus("Started new chat", 2000);
  }

  addMessage(content, isUser = false, images = null) {
    const chatContainer = document.getElementById("chatContainer");

    // Remove welcome message if it exists
    const welcomeMessage = chatContainer.querySelector(".welcome-message");
    if (welcomeMessage) {
      welcomeMessage.remove();
    }

    const messageDiv = document.createElement("div");
    messageDiv.className = `message ${isUser ? "user" : "assistant"}`;

    const avatar = document.createElement("div");
    avatar.className = "message-avatar";
    avatar.textContent = isUser ? "U" : "AI";

    const messageContent = document.createElement("div");
    messageContent.className = "message-content";

    const messageText = document.createElement("div");
    messageText.className = "message-text";
    messageText.textContent = content;

    // Add copy button
    const copyBtn = document.createElement("button");
    copyBtn.className = "copy-btn";
    copyBtn.innerHTML = `
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
      </svg>
    `;
    copyBtn.title = "Copy message";
    copyBtn.addEventListener("click", () => {
      this.copyToClipboard(content);
    });

    const messageActions = document.createElement("div");
    messageActions.className = "message-actions";
    messageActions.appendChild(copyBtn);

    messageContent.appendChild(messageText);
    messageContent.appendChild(messageActions);

    if (images && images.length > 0) {
      const imagesContainer = document.createElement("div");
      imagesContainer.className = "message-images";

      images.forEach((imageUrl) => {
        const imageWrapper = document.createElement("div");
        imageWrapper.className = "message-image";

        const img = document.createElement("img");
        img.src = imageUrl;
        img.alt = "Generated image";
        img.loading = "lazy";

        const actions = document.createElement("div");
        actions.className = "image-actions";
        actions.innerHTML = `
                    <button class="image-action-btn" onclick="realEngine.downloadImage('${imageUrl}')">⬇</button>
                    <button class="image-action-btn" onclick="realEngine.createVariation('${imageUrl}')">✨</button>
                `;

        imageWrapper.appendChild(img);
        imageWrapper.appendChild(actions);
        imagesContainer.appendChild(imageWrapper);
      });

      messageContent.appendChild(imagesContainer);
    }

    messageDiv.appendChild(avatar);
    messageDiv.appendChild(messageContent);

    chatContainer.appendChild(messageDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;

    // Add to chat history for context (only for chat mode)
    if (this.currentMode === "chat") {
      this.chatHistory.push({
        content: content,
        isUser: isUser,
        timestamp: Date.now(),
      });

      // Keep only last 20 messages to prevent context from getting too long
      if (this.chatHistory.length > 20) {
        this.chatHistory = this.chatHistory.slice(-20);
      }
    }

    return messageDiv;
  }

  async generateImage() {
    if (this.isGenerating) return;

    const prompt = document.getElementById("positivePrompt").value.trim();
    if (!prompt) {
      this.showStatus("Please enter a prompt", 3000);
      return;
    }

    // Content filtering check
    const filterResult = this.checkContentFilter(prompt);
    if (!filterResult.allowed) {
      this.showStatus(
        `Content not allowed. Please remove: "${filterResult.foundWord}"`,
        4000
      );
      console.log(
        `Blocked prompt due to disallowed word: ${filterResult.foundWord}`
      );
      return;
    }

    // Add to recent prompts
    this.addToRecentPrompts(prompt);

    // Get trigger words for selected LoRA and prepend if needed
    let finalPrompt = this.addLoRATriggerWords(prompt);

    this.isGenerating = true;
    this.updateGenerateButton(true);

    // Add user message (show original prompt to user)
    this.addMessage(prompt, true);

    // Add loading message
    const loadingMessage = this.addMessage("Generating image...", false);

    try {
      const formData = this.collectFormData();
      // Override the prompt with trigger words added
      formData.positivePrompt = finalPrompt;

      const response = await fetch("/generate", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(formData),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      // Remove loading message
      loadingMessage.remove();

      if (data.images && data.images.length > 0) {
        this.addMessage("Here's your generated image:", false, data.images);
        this.showStatus("Image generated successfully!", 3000);
      } else {
        this.addMessage(
          "Sorry, I couldn't generate an image. Please try again.",
          false
        );
        this.showStatus("Generation failed", 3000);
      }
    } catch (error) {
      console.error("Generation error:", error);
      loadingMessage.remove();
      this.addMessage(
        "An error occurred while generating the image. Please try again.",
        false
      );
      this.showStatus("Generation failed", 3000);
    } finally {
      this.isGenerating = false;
      this.updateGenerateButton(false);
      // Clear input after generation (consistent with chat mode)
      document.getElementById("positivePrompt").value = "";
      this.autoResizeTextarea(document.getElementById("positivePrompt"));
    }
  }

  collectFormData() {
    // Check if current model supports LoRA
    const isDreamModel = this.settings.model === "runware:97@1";

    console.log("collectFormData - Model:", this.settings.model);
    console.log("collectFormData - isDreamModel:", isDreamModel);
    console.log("collectFormData - settings.lora:", this.settings.lora);

    const formData = {
      positivePrompt: document.getElementById("positivePrompt").value,
      negativePrompt: this.settings.negativePrompt,
      width: this.settings.width,
      height: this.settings.height,
      model: this.settings.model,
      lora: isDreamModel ? "" : this.settings.lora, // Clear LoRA for Dream model
      lora2: isDreamModel ? "" : this.settings.lora2 || "", // Clear secondary LoRA for Dream model
      loraWeight: document.getElementById("loraWeight")
        ? parseFloat(document.getElementById("loraWeight").value)
        : 1.0,
      steps: this.settings.steps,
      CFGScale: this.settings.CFGScale,
      scheduler: this.settings.scheduler,
      seed: this.settings.seed,
      enhancePrompt: this.settings.enhancePrompt,
      outputFormat: this.settings.outputFormat,
      numberResults: this.settings.numberResults,
    };

    console.log("collectFormData - Final lora value:", formData.lora);
    return formData;
  }

  updateGenerateButton(isLoading) {
    const sendBtn = document.getElementById("sendBtn");
    sendBtn.disabled = isLoading;

    if (isLoading) {
      sendBtn.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 6v6l4 2"/>
                </svg>
            `;
    } else {
      sendBtn.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="22" y1="2" x2="11" y2="13"/>
                    <polygon points="22,2 15,22 11,13 2,9 22,2"/>
                </svg>
            `;
    }
  }

  async loadRandomPrompts() {
    try {
      const response = await fetch("/random-prompt");
      const data = await response.json();
      this.randomPrompts = data.prompts || [];
    } catch (error) {
      console.error("Failed to load random prompts:", error);
      this.randomPrompts = [
        "A serene landscape with mountains and a lake",
        "A futuristic city with flying cars",
        "A magical forest with glowing mushrooms",
        "A vintage car on a desert highway",
        "A cozy coffee shop in the rain",
      ];
    }
  }

  getRandomPrompt() {
    if (!this.randomPrompts || this.randomPrompts.length === 0) {
      this.loadRandomPrompts();
      return;
    }

    const randomPrompt =
      this.randomPrompts[Math.floor(Math.random() * this.randomPrompts.length)];
    const promptInput = document.getElementById("positivePrompt");
    promptInput.value = randomPrompt;
    this.autoResizeTextarea(promptInput);
    promptInput.focus();
  }

  showStatus(message, duration = 3000) {
    const statusEl = document.getElementById("status");
    statusEl.textContent = message;
    statusEl.classList.add("visible");

    setTimeout(() => {
      statusEl.classList.remove("visible");
    }, duration);
  }

  downloadImage(imageUrl) {
    const link = document.createElement("a");
    link.href = imageUrl;
    link.download = `realengine-${Date.now()}.jpg`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  createVariation(imageUrl) {
    // TODO: Implement image-to-image variation
    this.showStatus("Variation feature coming soon!", 3000);
  }

  initSettingsPanel() {
    // Set initial values from settings
    document.getElementById("modelSelect").value = this.settings.model;
    document.getElementById("loraSelect").value = this.settings.lora;
    document.getElementById("cfgScaleSlider").value = this.settings.CFGScale;
    document.getElementById("stepsSlider").value = this.settings.steps;
    document.getElementById("negativePromptInput").value =
      this.settings.negativePrompt;
    document.getElementById("enhancePromptToggle").checked =
      this.settings.enhancePrompt;
    document.getElementById("schedulerSelect").value = this.settings.scheduler;
    document.getElementById("seedInput").value = this.settings.seed;

    // Update display values
    document.getElementById("cfgScaleValue").textContent =
      this.settings.CFGScale.toFixed(2);
    document.getElementById("stepsValue").textContent =
      this.settings.steps.toFixed(2);
    document.getElementById("loraWeightValue").textContent = "1.00";

    // Set Square as active aspect ratio (matches iOS default)
    const squareBtn = document.querySelector(
      '.aspect-btn[data-width="1024"][data-height="1024"]'
    );
    if (squareBtn) {
      squareBtn.classList.add("active");
    }

    // Update hidden inputs
    Object.keys(this.settings).forEach((key) => {
      this.updateHiddenInput(key, this.settings[key]);
    });

    // Apply initial model defaults
    this.applyModelDefaults();

    // Handle LoRA compatibility
    this.handleLoRACompatibility(this.settings.model);

    // Initialize enhancer toggle state
    const enhancerBtn = document.getElementById("enhancerToggleBtn");
    if (this.settings.enhancePrompt) {
      enhancerBtn.classList.add("active");
    }

    // Restore mode from storage
    this.switchMode(this.currentMode);

    // Initialize personal LoRAs display
    this.updateLoraDropdown();
    this.renderPersonalLoras();
  }

  applyModelDefaults() {
    const model = this.settings.model;
    if (this.modelDefaults[model]) {
      this.settings.steps = this.modelDefaults[model].steps;
      this.settings.CFGScale = this.modelDefaults[model].CFGScale;

      // Update UI sliders
      document.getElementById("stepsSlider").value = this.settings.steps;
      document.getElementById("cfgScaleSlider").value = this.settings.CFGScale;
      document.getElementById("stepsValue").textContent =
        this.settings.steps.toFixed(2);
      document.getElementById("cfgScaleValue").textContent =
        this.settings.CFGScale.toFixed(2);

      // Update hidden inputs
      this.updateHiddenInput("steps", this.settings.steps);
      this.updateHiddenInput("CFGScale", this.settings.CFGScale);

      console.log(
        `Applied ${this.modelDefaults[model].name} defaults: Steps=${this.settings.steps}, CFG=${this.settings.CFGScale}`
      );
    }
  }

  switchMode(mode) {
    this.currentMode = mode;

    // Update mode button states
    document
      .querySelectorAll(".mode-btn")
      .forEach((btn) => btn.classList.remove("active"));
    document.getElementById(mode + "ModeBtn").classList.add("active");

    // Show/hide enhancer toggle based on mode
    const enhancerContainer = document.getElementById(
      "enhancerToggleContainer"
    );
    if (mode === "image") {
      enhancerContainer.classList.remove("hidden");
    } else {
      enhancerContainer.classList.add("hidden");
    }

    // Update input placeholder
    const textarea = document.getElementById("positivePrompt");
    if (mode === "image") {
      textarea.placeholder = "Describe the image you want to generate...";
      textarea.required = true;
    } else {
      textarea.placeholder =
        "Ask me anything about image generation, get prompt suggestions, or chat...";
      textarea.required = false;
    }

    // Update welcome message if showing
    this.updateWelcomeMessage();

    // Save to storage (but don't save on initial load)
    if (this.isInitialized) {
      this.saveToStorage();
    }

    console.log(`Switched to ${mode} mode`);
  }

  updateWelcomeMessage() {
    const chatContainer = document.getElementById("chatContainer");
    const welcomeMessage = chatContainer.querySelector(".welcome-message");

    if (welcomeMessage) {
      if (this.currentMode === "image") {
        welcomeMessage.innerHTML = `
          <h2>Welcome to RealEngine</h2>
          <p>Enter a prompt to generate AI images</p>
          <button class="random-prompt-btn" onclick="realEngine.getRandomPrompt()">Get Random Prompt</button>
        `;
      } else {
        welcomeMessage.innerHTML = `
          <h2>Chat with RealEngine AI</h2>
          <p>Ask questions, get prompt suggestions, or just chat!</p>
          <button class="random-prompt-btn" onclick="realEngine.askForPromptHelp()">Help me create a prompt</button>
        `;
      }
    }
  }

  async sendChatMessage() {
    if (this.isGenerating) return;

    const message = document.getElementById("positivePrompt").value.trim();
    if (!message) {
      this.showStatus("Please enter a message", 3000);
      return;
    }

    this.isGenerating = true;
    this.updateGenerateButton(true);

    // Add user message
    this.addMessage(message, true);

    // Add loading message
    const loadingMessage = this.addMessage("Thinking...", false);

    try {
      // Prepare chat history for API
      const history = this.chatHistory.map((msg) => ({
        type: msg.isUser ? "user" : "assistant",
        content: msg.content,
      }));

      const response = await fetch("/chat", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          message: message,
          history: history,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      // Remove loading message
      loadingMessage.remove();

      if (data.response) {
        this.addMessage(data.response, false);
        this.showStatus("Response received!", 2000);
      } else {
        this.addMessage(
          "Sorry, I couldn't process your message. Please try again.",
          false
        );
        this.showStatus("Chat failed", 3000);
      }
    } catch (error) {
      console.error("Chat error:", error);
      loadingMessage.remove();
      this.addMessage(
        "An error occurred while processing your message. Please try again.",
        false
      );
      this.showStatus("Chat failed", 3000);
    } finally {
      this.isGenerating = false;
      this.updateGenerateButton(false);
      // Clear input
      document.getElementById("positivePrompt").value = "";
      this.autoResizeTextarea(document.getElementById("positivePrompt"));
    }
  }

  askForPromptHelp() {
    const textarea = document.getElementById("positivePrompt");
    textarea.value =
      "Can you help me create a detailed prompt for generating a stunning AI image?";
    this.autoResizeTextarea(textarea);
    textarea.focus();
  }

  toggleEnhancer() {
    this.settings.enhancePrompt = !this.settings.enhancePrompt;

    // Update the toggle button appearance
    const enhancerBtn = document.getElementById("enhancerToggleBtn");
    if (this.settings.enhancePrompt) {
      enhancerBtn.classList.add("active");
    } else {
      enhancerBtn.classList.remove("active");
    }

    // Sync with settings panel toggle
    const settingsToggle = document.getElementById("enhancePromptToggle");
    if (settingsToggle) {
      settingsToggle.checked = this.settings.enhancePrompt;
    }

    // Update hidden input
    this.updateHiddenInput("enhanceToggle", this.settings.enhancePrompt);

    // Show status
    this.showStatus(
      `Prompt enhancement ${
        this.settings.enhancePrompt ? "enabled" : "disabled"
      }`,
      2000
    );

    // Save to storage
    this.saveToStorage();

    console.log(
      `Prompt enhancement ${
        this.settings.enhancePrompt ? "enabled" : "disabled"
      }`
    );
  }

  // Storage Methods
  saveToStorage() {
    const dataToSave = {
      settings: this.settings,
      currentMode: this.currentMode,
      recentPrompts: this.recentPrompts.slice(-20), // Keep last 20 prompts
      chatHistory: this.chatHistory.slice(-50), // Keep last 50 chat messages
      personalLoras: this.personalLoras, // Save personal LoRAs
      timestamp: Date.now(),
    };

    try {
      localStorage.setItem(this.storageKey, JSON.stringify(dataToSave));
      console.log("Data saved to localStorage");
    } catch (error) {
      console.error("Failed to save to localStorage:", error);
    }
  }

  loadFromStorage() {
    try {
      const savedData = localStorage.getItem(this.storageKey);
      if (savedData) {
        const data = JSON.parse(savedData);

        // Load settings if they exist
        if (data.settings) {
          this.settings = { ...this.settings, ...data.settings };
        }

        // Load mode if it exists
        if (data.currentMode) {
          this.currentMode = data.currentMode;
        }

        // Load recent prompts
        if (data.recentPrompts) {
          this.recentPrompts = data.recentPrompts;
        }

        // Load chat history
        if (data.chatHistory) {
          this.chatHistory = data.chatHistory;
        }

        // Load personal LoRAs
        if (data.personalLoras) {
          this.personalLoras = data.personalLoras;
        }

        console.log("Data loaded from localStorage");
      }
    } catch (error) {
      console.error("Failed to load from localStorage:", error);
    }
  }

  clearStorage() {
    try {
      localStorage.removeItem(this.storageKey);
      console.log("Storage cleared");
    } catch (error) {
      console.error("Failed to clear storage:", error);
    }
  }

  addToRecentPrompts(prompt) {
    if (prompt && prompt.trim()) {
      // Remove if already exists to avoid duplicates
      this.recentPrompts = this.recentPrompts.filter(
        (p) => p !== prompt.trim()
      );
      // Add to beginning
      this.recentPrompts.unshift(prompt.trim());
      // Keep only last 20
      this.recentPrompts = this.recentPrompts.slice(0, 20);
      this.saveToStorage();
    }
  }

  resetToDefaults() {
    // Clear storage
    this.clearStorage();

    // Reset settings to defaults
    this.settings = {
      width: 1024,
      height: 1024,
      model: "runware:97@1",
      lora: "",
      lora2: "",
      steps: 28,
      CFGScale: 3.5,
      negativePrompt: "worst quality, low quality, blurry",
      scheduler: "FlowMatchEulerDiscreteScheduler",
      seed: "",
      enhancePrompt: false,
      outputFormat: "JPG",
      numberResults: 1,
    };

    // Reset other data
    this.currentMode = "image";
    this.recentPrompts = [];
    this.chatHistory = [];
    this.personalLoras = [];

    // Update UI
    this.initSettingsPanel();
    this.switchMode("image");

    this.showStatus("Reset to defaults", 3000);
    console.log("App reset to defaults");
  }

  copyToClipboard(text) {
    const tempInput = document.createElement("input");
    tempInput.value = text;
    document.body.appendChild(tempInput);
    tempInput.select();
    document.execCommand("copy");
    document.body.removeChild(tempInput);
    this.showStatus("Message copied to clipboard", 2000);
  }

  checkContentFilter(prompt) {
    // Normalize the prompt for better detection
    let normalizedPrompt = prompt
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, "") // Remove special characters
      .replace(/\s+/g, " ") // Normalize whitespace
      .replace(/(\w)\s+(\w)/g, "$1$2") // Remove spaces between characters (e.g., "y o u n g" -> "young")
      .trim();

    // Also check the original prompt for phrase detection
    const lowerPrompt = prompt.toLowerCase();

    for (const word of this.disallowedWords) {
      const lowerWord = word.toLowerCase();

      // Check in normalized prompt (catches spacing tricks)
      if (normalizedPrompt.includes(lowerWord.replace(/\s+/g, ""))) {
        return {
          allowed: false,
          foundWord: word,
        };
      }

      // Check in original prompt (catches phrases with proper spacing)
      if (lowerPrompt.includes(lowerWord)) {
        return {
          allowed: false,
          foundWord: word,
        };
      }

      // Check for word boundaries to avoid false positives (but allow the above broader checks for evasion)
      const wordBoundaryRegex = new RegExp(
        `\\b${lowerWord.replace(/\s+/g, "\\s+")}\\b`,
        "i"
      );
      if (wordBoundaryRegex.test(prompt)) {
        return {
          allowed: false,
          foundWord: word,
        };
      }
    }

    // Additional checks for number patterns
    const agePatterns = [
      /\b1[3-7]\s*(yo|y\.o\.|year old|years old)\b/i,
      /\b(thirteen|fourteen|fifteen|sixteen|seventeen)\s*(yo|y\.o\.|year old|years old)\b/i,
      /\baged?\s*1[3-7]\b/i,
      /\b1[3-7]\s*and\s*(young|cute|sweet)\b/i,
    ];

    for (const pattern of agePatterns) {
      if (pattern.test(prompt)) {
        return {
          allowed: false,
          foundWord: "age-related content",
        };
      }
    }

    return { allowed: true };
  }

  clearHistory() {
    if (
      confirm(
        "Are you sure you want to clear all chat history? This action cannot be undone."
      )
    ) {
      // Clear chat history
      this.chatHistory = [];

      // Clear visual messages from current chat
      const chatContainer = document.getElementById("chatContainer");
      const messages = chatContainer.querySelectorAll(".message");
      messages.forEach((message) => message.remove());

      // Show welcome message again
      this.showWelcomeMessage();

      this.showStatus("Chat history cleared", 3000);
      this.saveToStorage();
      console.log("Chat history cleared");
    }
  }

  handleLoRACompatibility(model) {
    const loraSelect = document.getElementById("loraSelect");
    const loraSection = loraSelect.closest(".setting-section");

    if (model === "runware:97@1") {
      // Dream model
      // Disable LoRA controls
      loraSelect.disabled = true;
      loraSelect.value = "";
      this.settings.lora = "";
      this.updateHiddenInput("lora", "");

      // Add visual indication
      loraSection.style.opacity = "0.5";
      loraSection.title = "LoRA not compatible with Dream model";

      console.log("LoRA disabled for Dream model");
    } else {
      // Enable LoRA controls
      loraSelect.disabled = false;

      // Remove visual indication
      loraSection.style.opacity = "1";
      loraSection.title = "";

      console.log("LoRA enabled for", this.modelDefaults[model]?.name || model);
    }
  }

  addPersonalLora() {
    const nameInput = document.getElementById("personalLoraName");
    const idInput = document.getElementById("personalLoraId");
    const triggerInput = document.getElementById("personalLoraTrigger");

    const name = nameInput.value.trim();
    const airId = idInput.value.trim();
    const triggerWords = triggerInput.value.trim();

    if (!name || !airId) {
      this.showStatus("Please enter both name and AIR ID", 3000);
      return;
    }

    // Validate AIR ID format (basic validation)
    if (!airId.includes("air:") && !airId.includes("civitai:")) {
      this.showStatus(
        "Please enter a valid AIR ID (e.g., air:12345@6789)",
        3000
      );
      return;
    }

    // Check if already exists
    if (this.personalLoras.some((lora) => lora.id === airId)) {
      this.showStatus("This LoRA already exists", 3000);
      return;
    }

    // Add to personal LoRAs
    const newLora = {
      name: name,
      id: airId,
      triggerWords: triggerWords,
      timestamp: Date.now(),
    };

    this.personalLoras.push(newLora);

    // Clear inputs
    nameInput.value = "";
    idInput.value = "";
    triggerInput.value = "";

    // Update UI
    this.updateLoraDropdown();
    this.renderPersonalLoras();
    this.saveToStorage();

    this.showStatus(`Added "${name}" to personal LoRAs`, 2000);
    console.log("Added personal LoRA:", newLora);
  }

  removePersonalLora(airId) {
    this.personalLoras = this.personalLoras.filter((lora) => lora.id !== airId);

    // If currently selected LoRA is being removed, clear selection
    if (this.settings.lora === airId) {
      this.settings.lora = "";
      document.getElementById("loraSelect").value = "";
      this.updateHiddenInput("lora", "");
    }

    this.updateLoraDropdown();
    this.renderPersonalLoras();
    this.saveToStorage();

    this.showStatus("Personal LoRA removed", 2000);
  }

  updateLoraDropdown() {
    const loraSelect = document.getElementById("loraSelect");

    // Store current selection
    const currentValue = loraSelect.value;

    // Clear existing options except built-in ones
    loraSelect.innerHTML = `
      <option value="">None</option>
      <option value="civitai:652699@993999">Realism</option>
      <option value="civitai:682349@763724">360degree</option>
      <option value="civitai:757432@846937">LogoMaker</option>
      <option value="civitai:669582@749547">TextLogo</option>
      <option value="rundiffusion:500@100">Photo</option>
      <option value="civitai:1260139@1420893">Medieval</option>
    `;

    // Add personal LoRAs
    if (this.personalLoras.length > 0) {
      const separator = document.createElement("option");
      separator.disabled = true;
      separator.textContent = "── Personal LoRAs ──";
      loraSelect.appendChild(separator);

      this.personalLoras.forEach((lora) => {
        const option = document.createElement("option");
        option.value = lora.id;
        option.textContent = lora.name;
        loraSelect.appendChild(option);
      });
    }

    // Restore selection if it still exists
    if (currentValue) {
      loraSelect.value = currentValue;
    }
  }

  renderPersonalLoras() {
    const container = document.getElementById("personalLorasList");

    if (this.personalLoras.length === 0) {
      container.innerHTML =
        '<p style="color: var(--text-muted); font-size: 13px; text-align: center; padding: 16px;">No personal LoRAs added yet</p>';
      return;
    }

    container.innerHTML = this.personalLoras
      .map(
        (lora) => `
      <div class="personal-lora-item">
        <div class="personal-lora-info">
          <div class="personal-lora-name">${lora.name}</div>
          <div class="personal-lora-id">${lora.id}</div>
          ${
            lora.triggerWords
              ? `<div class="personal-lora-trigger">Trigger: ${lora.triggerWords}</div>`
              : ""
          }
        </div>
        <button class="remove-lora-btn" onclick="realEngine.removePersonalLora('${
          lora.id
        }')">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"/>
            <line x1="6" y1="6" x2="18" y2="18"/>
          </svg>
        </button>
      </div>
    `
      )
      .join("");
  }

  addLoRATriggerWords(prompt) {
    // Don't add trigger words if current model doesn't support LoRA
    const isDreamModel = this.settings.model === "runware:97@1";
    console.log("addLoRATriggerWords - Model:", this.settings.model);
    console.log("addLoRATriggerWords - isDreamModel:", isDreamModel);

    if (isDreamModel) {
      console.log(
        "addLoRATriggerWords - Returning original prompt (Dream model)"
      );
      return prompt;
    }

    const selectedLora = this.settings.lora;
    console.log("addLoRATriggerWords - selectedLora:", selectedLora);

    if (!selectedLora) {
      console.log(
        "addLoRATriggerWords - No LoRA selected, returning original prompt"
      );
      return prompt;
    }

    let triggerWords = "";

    // Check built-in LoRAs
    if (this.builtInLoras[selectedLora]) {
      triggerWords = this.builtInLoras[selectedLora].triggerWords;
    } else {
      // Check personal LoRAs
      const personalLora = this.personalLoras.find(
        (lora) => lora.id === selectedLora
      );
      if (personalLora && personalLora.triggerWords) {
        triggerWords = personalLora.triggerWords;
      }
    }

    console.log("addLoRATriggerWords - triggerWords:", triggerWords);

    if (triggerWords && triggerWords.trim()) {
      // Don't add trigger words if they're already in the prompt
      const lowerPrompt = prompt.toLowerCase();
      const lowerTrigger = triggerWords.toLowerCase();
      if (!lowerPrompt.includes(lowerTrigger)) {
        const finalPrompt = `${triggerWords} ${prompt}`;
        console.log(
          "addLoRATriggerWords - Adding trigger words. Final prompt:",
          finalPrompt
        );
        return finalPrompt;
      }
    }

    console.log(
      "addLoRATriggerWords - Returning original prompt (no trigger words to add)"
    );
    return prompt;
  }
}

// Initialize the application
let realEngine;
document.addEventListener("DOMContentLoaded", () => {
  realEngine = new RealEngine();
});

// Export for global access
window.realEngine = realEngine;
